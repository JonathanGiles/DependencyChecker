package net.jonathangiles.tool.maven.dependencies.report;

import net.jonathangiles.tool.maven.dependencies.model.Dependency;
import net.jonathangiles.tool.maven.dependencies.model.DependencyVersion;
import net.jonathangiles.tool.maven.dependencies.model.Version;
import net.jonathangiles.tool.maven.dependencies.project.Project;
import org.jboss.shrinkwrap.resolver.api.maven.Maven;
import org.jboss.shrinkwrap.resolver.api.maven.MavenResolverSystem;
import org.jboss.shrinkwrap.resolver.api.maven.coordinate.MavenCoordinate;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

public class HTMLReport implements Report {
    private final File outFile;
    private final StringBuilder sb;

    private final MavenResolverSystem mavenResolver;

    private final Map<String, String> resolvedVersionsWithNoQualifiers;
    private final Map<String, String> resolvedVersions; // this map contains values with or without qualifiers

    public HTMLReport(File outFile) {
        this.outFile = outFile;
        this.sb = new StringBuilder();
        this.mavenResolver = Maven.resolver();
        this.resolvedVersionsWithNoQualifiers = new HashMap<>();
        this.resolvedVersions = new HashMap<>();
    }

    @Override
    public void report(List<Project> projects, List<Dependency> problems) {
        out("<html>");
        out("  <head>");
        out("    <title>Dependency Issues Report</title>");
        out("    <style>");

        // write out CSS inline
        try (BufferedReader r = Files.newBufferedReader(Paths.get(getClass().getResource("report.css").toURI()))) {
            r.lines().forEach(line -> out("      " + line));
        } catch (Exception e) {
            // no-op
        }

        out("    </style>");
        out("  </head>");
        out("  <body>");

        out("    <center>");

        // Summary table
        out("      <h1>Dependency Issues Report</h1>");
        out("      <p>This report scanned the Maven releases listed in the first table below, and reports on occasions where there are conflicting dependency versions.<br/>" +
                "If you feel any of these libraries should not be included, or if the versions are out of date, or if a library is missing, please contact <a href=\"mailto:jonathan.giles@microsoft.com\">Jonathan</a>.<br/>" +
                "Hover over dashed lines to see the dependency chain, if there is not a direct relationship between the dependency and the project.</p>");

        // summary of the projects we scanned
        printProjects(projects);

        // results
        problems.stream().filter(Dependency::isProblemDependency).forEach(this::process);

        out("      <small>Report generated by <a href=\"http://jonathangiles.net\">Jonathan Giles</a> - <a href=\"mailto:jonathan.giles@microsoft.com\">Email</a></small>");
        out("    </center>");
        out("  </body>");
        out("</html>");

        // write out to the output file
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(outFile))) {
            writer.write(sb.toString());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void printProjects(List<Project> projects) {
        out("    <table class=\"condensed\">");
        out("      <thead>");
        out("        <tr><th colspan=\"2\">Maven Releases Scanned for this Report</th></tr>");
        out("        <tr><th>Library Analysed</th><th>Latest Released Version</th></tr>");
        out("      </thead>");
        out("      <tbody>");

        for (Project project : projects) {
            out("      <tr>");
            out("        <td>" + project.getFullProjectName() + "</td>");
            out("        <td>" + getLatestVersion(project.getProjectName(), true) + "</td>");
            out("      </tr>");
        }

        out("      </tbody>");
        out("    </table>");
        out("    <br/>");
    }

    private void process(Dependency dependency) {
        String latestReleasedVersion = getLatestVersion(dependency.getGA(), false);

        out("    <table>");
        out("      <thead>");
        out("        <tr><th colspan=\"2\"><u>Dependency:</u> " + dependency.getGA() +
                             "<br/>Latest Released Version: " + latestReleasedVersion + "</th></tr>");
        out("      </thead>");
        out("      <tbody>");

        List<String> versions = dependency.getVersions()
                .stream()
                .sorted(Comparator.comparing(Version::build).reversed())
                .collect(Collectors.toList());

        if (!versions.get(0).equals(latestReleasedVersion)) {
            out("      <tr>");
            out("        <td class=\"version\">" + latestReleasedVersion + "</td>");
            out("        <td><i>&lt;No dependencies on latest version&gt;</i></td>");
            out("      </tr>");
        }

        versions.forEach(version -> {
            out("      <tr>");
            out("        <td class=\"version\">" + version + "</td>");
            out("        <td>");

            dependency
                    .getDependenciesOnVersion(version)
                    .entrySet()
                    .stream()
                    .sorted(Comparator.comparing(e -> e.getKey().getFullProjectName()))
                    .forEach(e -> {
                        Optional<List<String>> chain = e.getValue().stream()
                                .filter(DependencyVersion::hasDependencyChain)
                                .sorted(Comparator.comparingInt(DependencyVersion::getDependencyChainSize).reversed())
                                .limit(1)
                                .findFirst()
                                .map(DependencyVersion::getDependencyChain);

                        if (chain.isPresent()) {
                            List<String> chainItems = chain.get();
                            chainItems.add(0, e.getKey().getFullProjectName());
                            chainItems.add(dependency.getGA() + ":" + version);

                            StringBuilder chainString = new StringBuilder();

                            chainString.append("<u>Dependency Chain</u><br/>");

                            for (int i = 0; i < chainItems.size(); i++) {
                                for (int indent = 1; indent < 4 * i; indent++) {
                                    chainString.append("&nbsp;");
                                }

                                String ga = chainItems.get(i);
                                chainString.append("- ");
                                chainString.append(ga);

                                String latestVersion = getLatestVersion(ga, false);
                                if (latestVersion != null && !latestVersion.isEmpty()) {
                                    chainString.append(" (Latest version: " + latestVersion + ")");
                                }

                                chainString.append("<br/>");
                            }

                            out("<div class=\"tooltip\">" + e.getKey().getFullProjectName() + "<span class=\"tooltiptext\">" + chainString.toString() + "</span></div><br/>");
                        } else {
                            out(e.getKey().getFullProjectName() + "<br/>");
                        }
                    });

            out("        </td>");
            out("      </tr>");
        });

        out("      </tbody>");
        out("    </table>");
        out("    <br/>");
    }
    
    private void out(String s) {
        sb.append(s);
        sb.append("\r\n");
    }

    private String getLatestVersion(String ga, boolean acceptQualifiers) {
        Map<String, String> mapToLookup = acceptQualifiers ? resolvedVersions : resolvedVersionsWithNoQualifiers;

        return mapToLookup.computeIfAbsent(ga, key -> {
            Optional<MavenCoordinate> result = mavenResolver.resolveVersionRange(key + ":[0.1,)")
                            .getVersions()
                            .stream()
                            .filter(coor -> acceptQualifiers || !coor.getVersion().contains("-")) // we don't want -SNAPSHOT, etc
                            .reduce((first, second) -> second); // the highest version is the last version
            return result.isPresent() ? result.get().getVersion() : "";
        });
    }
}
